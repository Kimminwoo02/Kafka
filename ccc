카프카

카프카 사용이유
타겟 : DB, 분석, 이메일 시스템, 감사 시스템 등  
- 아파치 카프카에서 시스템 전체를 끄지 않고 유지 가능
- 수평적 스케일업이 가능 시간이 지나면 카프카 클러스터에 추가할 수 있다.
- 메세지의 대규모 처리가 가능하다.

활용사례
- 메세징 시스템 활동추적
- 메트릭 정보를 모으는데 사용
- 애플리케이션 로그를 수집하는 용도로 사용
- 스트림 처리 가능
- 빅데이터 통합 기술로도 사용
- 마이크로서비스 발행/구독에 사용

예시) 
- 넷플릭스의 실시간 추천 시스템
- 우버의 여행 데이터를 실시간 수집하고 요금 계산
- 링크드인은 유저 상호작용을 모아서 더 나은 실시간 관계 추천을 해줌
위의 모든 것은 카프카의 운송 메커니즘으로서만 사용됨




토픽
- 클러스터 안에 있는 데이터 스트림이다. 이름을 지정할 수 있다. 데이터베이스로 치면 테이블과 비슷하다.(제약조건x)
- 여러 타입의 포맷을 지원(json, 텍스트등)
- 토픽 안의 메세지 순서를 데이터 스트림이라 한다.
- 토픽에서 데이터를 읽기 위해 컨슈머를 사용한다.

파티션 
토픽을 파티션 단위로 나눌 수 있다.
- 메세지에서 나온 데이터는 파티션으로 간다.
- 데이터는 자동으로 증가하는 id를 가지는데 이를 파티션 오프셋이라한다.
- immutable한 특성을 가진다.
- 카프카의 데이터는 일정한 시간동안 유지된다.

 메세지의 순서는 한 파티션 안에서만 보장된다.

 프로듀서
 토픽과 파티션에 데이터를 전달하는 개체로, 자신이 어떤 파티션에 기록하는지 미리 알고있다.
 - 브로커(서버)가 그걸 갖게 된다.
 - 파티션이 고장나면 어떻게 복구할지 프로듀서가 알게 된다.
 - 로드벨런싱을 가지고 있다.
 - 메세지 키를 가지고 있다. 메세지 자체에 데이터를 보유하고있고 여기에 키를 추가할 수 있다는 뜻
    키가 널이라면 라운드 로빈 방식으로 전달된다.
 - 동일한 키를 공유하는 모든 메세지들은 해싱 전략덕분에 같은 파티션에 기록된다.
 
 메세지 구성
 키-바이너리, 값 - 바이너리
 압축 타입(gzip,snappy,)
 헤더(선택사항)
 파티션+ 오프셋
 타임스탬프


Message Seriralizer
- 메세지를 생성하는 방법이다.
- 입력과 출력값으로 바이트로 받는다. 
- 직렬화는 데이터나 객체를 바이트로 변환한다는 의미이다.
- 값과 키에만 사용된다.

컨슈머
데이터를 읽는 개체로, 카프카 브로커에 데이터를 요청하고 되돌아오는 응답을 받는다.
- 컨슈머가 자동으로 어떤 브로커에서 데이터를 읽을지 알고있다.
- 브로커가 고장날 경우 컨슈머가 자동으로 복구한다.
- 데이터는 낮은 오프셋부터 높은 오프셋 순서로 읽게 된다.

Consumer Deserializer
바이너리 형식으로된 키와 값을 역직렬화 하는 과정이다.

컨슈머 그룹
컨슈머를 데이터형태로 읽는다. 이를 컨슈머 그룹이라고 한다.
컨슈머 오프셋


브로커
카프카 클러스터는 여러 개의 브로커들로 구성되어 있다. 그냥 서버라고 보면 된다.
- 각각의 브로커들은 ID로 식별한다.
- 각각의 브로커는 특정한 토픽 파티션만 담긴다.
3개의 브로커 안에 토픽A와 토픽B가 있고 각각 3개의 파티션, 2개의 파티션을 가지고 있다면
모든 브로커에 걸쳐 분산될 것이다. 

브로커 발견 매커니즘
클러스터에 있는 각각의 브로커를 부트스트랩 서버라고 한다. 
5개의 서버로 이루어진 클러스터에서 브로커 하나에만 연결하면 클라이언트 전체 클러스터에 연결하는 방법을 알게 된다는 점이다.
브로커101이 연결에 성공하면 클러스터 내의 모든 노드에 리스트를 리턴한다.


